<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo.jpg"/>
	<link rel="shortcut icon" href="/img/logo.jpg">
	
			    <title>
    Ya'Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="ya" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/black.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">YA</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Learning/">Learning</a></li><li><a class="category-link" href="/categories/Reading/">Reading</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/heya30" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://image-1111.oss-cn-beijing.aliyuncs.com/img/_1fVd1HodkA.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Preparation for the interview in English</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h3 id="一-数学"><a href="#一-数学" class="headerlink" title="一. 数学"></a>一. 数学</h3><h4 id="1-1-线代"><a href="#1-1-线代" class="headerlink" title="1.1 线代"></a>1.1 线代</h4><p>rank 秩    Order 阶    determinant 行列式    cofactor 余子式    Augmented 增广    infinite 无穷</p>
<p>Gauss elimination 高斯消元    Eigenvalues 特征值    eigenvectors 特征向量    Substitute to 代入</p>
<p>homogeneous equation 齐次方程    nonhomogeneous equation 非齐次方程</p>
<p>similar matrix P-1AP = B    Diagonal matrix 对角矩阵    Linearly correlation 线性相关</p>
<p>Linear independence 线性无关    Elementary transformation 初等变化</p>
<p>n阶矩阵相似于对角矩阵的充要条件是，A有n个线性无关的特征向量，相似变换矩阵P的n个列向量是A的对应于这些特征值的n个线性无关的特征向量</p>
<h4 id="1-2-微积分-Calculus"><a href="#1-2-微积分-Calculus" class="headerlink" title="1.2 微积分 Calculus"></a>1.2 微积分 Calculus</h4><p>integral 积分    derivative 导数    limits 极限    Differential Calculus and Integral Calculus 微分和积分</p>
<p>f(n+1)(a) / (n+1)! * (x-x0)^(n+1)</p>
<h4 id="1-3-概率论"><a href="#1-3-概率论" class="headerlink" title="1.3 概率论"></a>1.3 概率论</h4><p>Permutations 排列    Combinations  组合    Factorial 阶乘</p>
<p>nth power of 2 / 2 to the nth power 2的n次方 </p>
<h3 id="二-专业课"><a href="#二-专业课" class="headerlink" title="二. 专业课"></a>二. 专业课</h3><h4 id="2-1-算法与数据结构"><a href="#2-1-算法与数据结构" class="headerlink" title="2.1 算法与数据结构"></a>2.1 算法与数据结构</h4><p>Sacrifice  牺牲</p>
<p>traverse 遍历</p>
<p>Synchronize 同步</p>
<h5 id="2-1-1-排序"><a href="#2-1-1-排序" class="headerlink" title="2.1.1 排序"></a>2.1.1 排序</h5><p>performance, space complexity, stable</p>
<p>Recursive relationship</p>
<ul>
<li><p>Complexity of n squre O(n^2)</p>
<ul>
<li><p>Bubble sort</p>
<p>Bubble Sort works by stepping through the list repeatedly comparing adjacent elements and swapping them if they are in wrong order.</p>
</li>
<li><p>Insertion Sort</p>
<p>Insertion sort works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.</p>
</li>
<li><p>Selection Sort</p>
<p>The selection sort algorithm divides the input list into two parts one sorted and one unsorted. Initially the sorted section is empty and the unsorted section is the entir list. Selection sort then finds the minimum element (considering ascending order) from unsorted part and swaps it with the leftmost element of the unsorted section. Thereby it increases the size of the sorted sction one by one. Selection sort then repeats this process until the sorted section is the size of the entire list selection sort.</p>
</li>
</ul>
</li>
<li><p>O(nlogn)</p>
<ul>
<li><p>Merge Sort</p>
<p>Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves until we are left with lists of size 1 , and then merges the two sorted halves. </p>
<p>归并排序有一个缺点，在进行子数组合并的时候，我们需要临时申请一个数组来暂时存放排好序的数据。因为这个临时空间是可以重复利用的，因此归并排序的空间复杂度为 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]">，最多需要存放 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 个数据。</p>
<p>extra space O(N)</p>
</li>
<li><p>Quick Sort</p>
<p>QuickSort picks an element as pivot, and then put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. Once this step is completed the pivot element is in its final position and the input list has been partitioned into two sub lists. Then we recursively applies the same steps to each sub-list until it has sub-lists of at most one element.</p>
<p>快排的空间复杂度是O(lgn)，因为快排的实现是递归调用的， 而且每次函数调用中只使用了常数的空间，因此空间复杂度等于递归深度Θ(lgn)。</p>
</li>
<li><p>Heap Sort</p>
<p>Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the minimum element and place the minimum element at the beginning. We repeat the same process for the remaining elements.</p>
</li>
</ul>
</li>
</ul>
<h5 id="2-1-2-二分"><a href="#2-1-2-二分" class="headerlink" title="2.1.2 二分"></a>2.1.2 二分</h5><p><strong>Binary Search:</strong> Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.</p>
<h5 id="2-1-3-栈"><a href="#2-1-3-栈" class="headerlink" title="2.1.3 栈"></a>2.1.3 栈</h5><p>Stack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out).</p>
<p>Mainly the following three basic operations are performed in the stack:</p>
<ul>
<li><strong>Push:</strong> Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition.</li>
<li><strong>Pop:</strong> Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.</li>
<li><strong>Peek or Top:</strong> Returns top element of stack.</li>
</ul>
<p>A Queue is a linear structure which follows a particular order in which the operations are performed. The order is First In First Out (FIFO).  </p>
<p>Mainly the following four basic operations are performed on queue:</p>
<ul>
<li>Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.</li>
<li>Dequeue: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition. </li>
<li>Front: Get the front item from queue. </li>
<li>Rear: Get the last item from queue. </li>
</ul>
<p><strong>two stacks -&gt; queue</strong></p>
<p>We are given a stack data structure with push and pop operations, the task is to implement a queue using instances of stack data structure and operations on them.</p>
<p><strong>Method 1 (By making enQueue operation costly)</strong> This method makes sure that oldest entered element is always at the top of stack 1, so that deQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.</p>
<ol>
<li>enQueue(q, x):<ul>
<li>While stack1 is not empty, push everything from stack1 to stack2.</li>
<li>Push x to stack1 </li>
<li>Push everything back to stack1.</li>
</ul>
</li>
<li>deQueue(q)<ul>
<li>If stack1 is empty then error</li>
<li>Pop an item from stack1 and return it</li>
</ul>
</li>
</ol>
<p>**Method 2 (By making deQueue operation costly)**In this method, in en-queue operation, the new element is entered at the top of stack1. In de-queue operation, if stack2 is empty then all the elements are moved to stack2 and finally top of stack2 is returned. </p>
<ol>
<li><p>enQueue(q,  x)</p>
<ul>
<li>Push x to stack1 </li>
</ul>
</li>
<li><p>deQueue(q)</p>
<ul>
<li>If stack2 is empty<pre><code>While stack1 is not empty, push everything from stack1 to stack2.
</code></pre>
</li>
<li>Pop the element from stack2 and return it.</li>
</ul>
</li>
</ol>
<p><strong>two queues -&gt; stack</strong></p>
<p>We are given a Queue data structure that supports standard operations like enqueue() and dequeue()</p>
<p><strong>Method 1 (By making push operation costly)</strong><br>This method makes sure that newly entered element is always at the front of ‘q1’, so that pop operation just dequeues from ‘q1’. ‘q2’ is used to put every new element at front of ‘q1’.</p>
<ol>
<li><p>push(s, x)</p>
<ul>
<li>Enqueue x to q2</li>
</ul>
</li>
</ol>
<ul>
<li>One by one dequeue everything from q1 and enqueue to q2.<ul>
<li>Swap the names of q1 and q2</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>pop(s)</p>
<ul>
<li>Dequeue an item from q1 and return it.</li>
</ul>
</li>
</ol>
<p><strong>Method 2 (By making pop operation costly)</strong><br>In push operation, the new element is always enqueued to q1. In pop() operation, if q2 is empty then all the elements except the last, are moved to q2. Finally the last element is dequeued from q1 and returned.</p>
<ol>
<li><p>push(s, x) </p>
<p>operation:</p>
<ul>
<li>Enqueue x to q1 (assuming size of q1 is unlimited).</li>
</ul>
</li>
<li><p>pop(s) </p>
<p>operation:</p>
<ul>
<li>One by one dequeue everything except the last element from q1 and enqueue to q2.</li>
<li>Dequeue the last item of q1, the dequeued item is result, store it.</li>
<li>Swap the names of q1 and q2</li>
<li>Return the item stored in step 2.</li>
</ul>
</li>
</ol>
<h5 id="2-1-4-树"><a href="#2-1-4-树" class="headerlink" title="2.1.4 树"></a>2.1.4 树</h5><p><strong>Binary tree</strong></p>
<p>Full Binary Tree</p>
<p>Complete Binary Tree</p>
<p>Perfect Binary Tree </p>
<ul>
<li>A Tree is typically traversed in two ways:<ul>
<li>Breadth First Traversal</li>
<li>Depth First Traversals<ul>
<li>Inorder Traversal (Left-Root-Right)</li>
<li>Preorder Traversal (Root-Left-Right)</li>
<li>Postorder Traversal (Left-Right-Root)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-1-5-散列"><a href="#2-1-5-散列" class="headerlink" title="2.1.5 散列"></a>2.1.5 散列</h5><p>Hash Table: An array that stores pointers to records corresponding to a given phone number. An entry in hash table is NIL if no existing phone number has hash function value equal to the index for the entry.</p>
<p><strong>Collision Handling</strong>: Since a hash function gets us a small number for a big key, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique. Following are the ways to handle collisions:</p>
<ul>
<li>**Chaining:**The idea is to make each cell of hash table point to a linked list of records that have same hash function value. Chaining is simple, but requires additional memory outside the table.</li>
<li><strong>Open Addressing:</strong> In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we one by one examine table slots until the desired element is found or it is clear that the element is not in the table.</li>
</ul>
<h5 id="2-1-6-优先队列"><a href="#2-1-6-优先队列" class="headerlink" title="2.1.6 优先队列"></a>2.1.6 优先队列</h5><p>A Heap is a special Tree-based data structure in which the tree is a complete binary tree. Generally, Heaps can be of two types:</p>
<ol>
<li><strong>Max-Heap</strong>: In a Max-Heap the key present at the root node must be greatest among the keys present at all of it’s children. The same property must be recursively true for all sub-trees in that Binary Tree.</li>
<li><strong>Min-Heap</strong>: In a Min-Heap the key present at the root node must be minimum among the keys present at all of it’s children. The same property must be recursively true for all sub-trees in that Binary Tree.</li>
</ol>
<h5 id="2-1-7-图"><a href="#2-1-7-图" class="headerlink" title="2.1.7 图"></a>2.1.7 图</h5><p>representations of a graph. </p>
<ol>
<li>Adjacency Matrix </li>
<li>Adjacency List </li>
</ol>
<p><strong>Topological sorting</strong> for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u v, vertex u comes before v in the ordering.</p>
<ol>
<li>Initialize all vertices as unvisited.</li>
<li>Now choose vertex which is unvisited and has zero indegree and decrease indegree of all those vertices by 1 (corresponding to removing edges) now add this vertex to result and call the recursive function again and backtrack.</li>
</ol>
<p><strong>Dijkstra’s shortest path algorithm</strong></p>
<ol>
<li>Create a set <em>sptSet</em> (shortest path tree set) that keeps track of vertices included in shortest path tree, i.e., whose minimum distance from source is calculated and finalized. Initially, this set is empty.</li>
<li>Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first. </li>
<li>While <em>sptSet</em> doesn’t include all vertices <ul>
<li>Pick a vertex u which is not there in <em>sptSet</em> and has minimum distance value. </li>
<li>Include u to <em>sptSet</em>. </li>
<li>Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. </li>
</ul>
</li>
</ol>
<p><strong>Prim</strong></p>
<p>It starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight edge from these edges. </p>
<h5 id="2-1-8-算法思想"><a href="#2-1-8-算法思想" class="headerlink" title="2.1.8 算法思想"></a>2.1.8 算法思想</h5><p>动态规划  Dynamic Programming</p>
<ul>
<li><p>Top-down Dynamic Programming with Memoization </p>
<p>Memoization is when we store the results of all the previously solved sub-problems and return the results from memory if we encounter a problem that has already been solved.</p>
<p>Since we have two changing values (<code>capacity</code> and <code>currentIndex</code>) in our recursive function <code>knapsackRecursive()</code>, we can use a two-dimensional array to store the results of all the solved sub-problems. As mentioned above, we need to store results for every sub-array (i.e., for every possible index ‘i’) and every possible capacity ‘c.’</p>
</li>
<li><p>Bottom-up Dynamic Programming </p>
<p>Let’s try to populate our <code>dp[][]</code> array from the above solution by working in a bottom-up fashion. Essentially, we want to find the maximum profit for every sub-array and every possible capacity. <strong>This means that <code>dp[i][c]</code> will represent the maximum knapsack profit for capacity ‘c’ calculated from the first ‘i’ items.</strong></p>
<p>So, for each item at index ‘i’ (0 &lt;= i &lt; items.length) and capacity ‘c’ (0 &lt;= c &lt;= capacity), we have two options:</p>
<ol>
<li>Exclude the item at index ‘i.’ In this case, we will take whatever profit we get from the sub-array excluding this item =&gt; <code>dp[i-1][c]</code></li>
<li>Include the item at index ‘i’ if its weight is not more than the capacity. In this case, we include its profit plus whatever profit we get from the remaining capacity and from remaining items =&gt; <code>profit[i] + dp[i-1][c-weight[i]]</code></li>
</ol>
<p>Finally, our optimal solution will be maximum of the above two values:</p>
<pre><code>dp[i][c] = max (dp[i-1][c], profit[i] + dp[i-1][c-weight[i]]) 
</code></pre>
</li>
</ul>
<p>贪婪算法 Greedy Algorithms</p>
<p>分治 Divide and Conquer</p>
<p>Solution with XOR</p>
<p>The following two properties of XOR:</p>
<ul>
<li>It returns zero if we take XOR of two same numbers.</li>
<li>It returns the same number if we XOR with zero.</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2021/07/20/interview-preparation/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2021/07/20/interview-preparation/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
